import { PendingAsyncCollection } from './pending-async-collection';
export declare class SyncCollection<T> {
    /**
     * Stores the list of items in the collection.
     */
    private readonly items;
    /**
     *
     * @param items
     * @param callChain
     */
    constructor(items: T | T[]);
    /**
     * Returns the array of items.
     *
     * @returns {Array}
     */
    all(): T[];
    /**
     * Alias for the `.some` method. This function determines
     * whether any item in the `array` passes the truth test
     * implemented by the given `callback` function.
     *
     * @param {Function} callback
     *
     * @returns {Boolean}
     */
    any(callback: (value: T, index: number, items: T[]) => Promise<unknown>): Promise<boolean>;
    any(callback: (value: T, index: number, items: T[]) => unknown): boolean;
    /**
     * Returns the average of all collection items
     *
     * @returns {Number}
     */
    avg(): number;
    /**
     * Breaks the collection into multiple, smaller collections of the given `size`.
     *
     * @param {Number} size
     *
     * @returns {SyncCollection}
     */
    chunk(size: number): SyncCollection<T[]>;
    /**
     * Creates a shallow clone of the collection.
     *
     * @returns {SyncCollection}
     */
    clone(): SyncCollection<T>;
    /**
     * Collapse a collection of arrays into a single, flat collection.
     *
     * @returns {SyncCollection}
     */
    collapse(): SyncCollection<T>;
    /**
     * Removes all falsy values from the given `array`. Falsy values
     * are `null`, `undefined`, `''`, `false`, `0`, `-0`, `0n`, `NaN`.
     *
     * @returns {SyncCollection}
     */
    compact(): SyncCollection<T>;
    /**
     * Creates a new collection containing the concatenated items
     * of the original collection with the new `items`.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    concat(...items: T[]): SyncCollection<T>;
    /**
     * Counts the items in the collection. By default, it behaves like an alias
     * for the `size()` method counting each individual item. The `callback`
     * function allows you to count a subset of items in the collection.
     *
     * @param {Function} predicate
     *
     * @returns {Number}
     */
    count(predicate?: (item: T, index: number) => unknown): number;
    count(predicate?: (item: T, index: number) => Promise<unknown>): Promise<number>;
    /**
     * Removes all values from the collection that are present in the given array.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    diff(items: T[]): SyncCollection<T>;
    /**
     * Asynchronous version of `Array#every()`, running the (async) testing
     * function in sequence. Returns `true` if all items in the collection
     * pass the check implemented by the `callback`, otherwise `false`.
     *
     * @param {Function} callback
     *
     * @returns {Boolean} Returns `true` if all items pass the predicate check, `false` otherwise.
     */
    every(predicate: (value: T, index: number, items: T[]) => unknown): boolean;
    every(predicate: (value: T, index: number, items: T[]) => Promise<unknown>): Promise<boolean>;
    /**
     * Asynchronous version of Array#filter(), running the (async) testing
     * function in sequence. The `callback` should return `true`
     * if an item should be included in the resulting collection.
     *
     * @param {Function} predicate
     *
     * @returns {Array}
     */
    filter(predicate: (value: T, index: number, items: T[]) => Promise<unknown>): PendingAsyncCollection<T>;
    filter(predicate: (value: T, index: number, items: T[]) => unknown): SyncCollection<T>;
    /**
     * A variant of the `filter` method running the (async) testing
     * function only if the given `condition` is `true`.
     *
     * @param {Boolean} condition
     * @param {Function} callback
     *
     * @returns {Array}
     */
    filterIf(condition: boolean, predicate: (value: T, index: number, items: T[]) => Promise<unknown>): PendingAsyncCollection<T>;
    filterIf(condition: boolean, predicate: (value: T, index: number, items: T[]) => unknown): this;
    /**
     * Asynchronous version of Array#find(), running the (async) testing
     * function in sequence. Returns the first item in the collection
     * satisfying the given `callback`, `undefined` otherwise.
     *
     * @param {Function} predicate
     *
     * @returns {*} the found value
     */
    find(predicate: (value: T, index: number, items: T[]) => T): T | undefined;
    find(predicate: (value: T, index: number, items: T[]) => Promise<T>): Promise<T>;
    /**
     * Returns the first item in the collection. This method behaves like
     * Array#find if you provide a `predicate` function.
     *
     * @param {Function} predicate
     *
     * @returns {*} the found value
     */
    first(): T | undefined;
    first(predicate?: (value: T, index: number, items: T[]) => T): T | undefined;
    first(predicate?: (value: T, index: number, items: T[]) => Promise<T>): PendingAsyncCollection<T>;
    /**
     * Flattens the collection one level deep.
     *
     * @returns {SyncCollection}
     */
    flatten(): SyncCollection<T>;
    /**
     * Asynchronous version of Array#flatMap(). It invokes the `action` callback
     * on each collection item. The callback can modify and return the item
     * resulting in a new collection of modified items. At the end,
     * flatMap flattens the mapped results.
     *
     * @param {Function} action
     *
     * @returns {SyncCollection}
     */
    flatMap<R>(action: (value: T, index: number, items: T[]) => R[]): SyncCollection<R>;
    flatMap<R>(action: (value: T, index: number, items: T[]) => Promise<R[]>): PendingAsyncCollection<R>;
    /**
     * Asynchrounous version of Array#forEach(), running the given
     * `action` function on each `array` item in sequence.
     *
     * @param {Function} action
     */
    forEach(action: (value: T, index: number, items: T[]) => void): void;
    forEach(action: (value: T, index: number, items: T[]) => Promise<void>): Promise<void>;
    /**
     * Group the collection items into arrays using the given `key`.
     *
     * @param {String} key
     *
     * @returns {Object}
     */
    groupBy(key: string): any;
    /**
     * Determines whether the the collection contains the item
     * represented by `callback` or if the collection
     * satisfies the given `callback` testing function. Alias of `includes`.
     *
     * @param {Function} predicate
     *
     * @returns {Boolean}
     */
    has(predicate: (value: T, index: number, items: T[]) => any): boolean;
    has(predicate: (value: T, index: number, items: T[]) => Promise<any>): Promise<boolean>;
    /**
     * Returns `true` when the collection contains duplicate items, `false` otherwise.
     *
     * @returns {Boolean}
     */
    hasDuplicates(): boolean;
    /**
     * Determines whether the the collection contains the item
     * represented by `callback` or if the collection
     * satisfies the given `callback` testing function. Alias of `has`.
     *
     * @param {Function} predicate
     *
     * @returns {Boolean}
     */
    includes(predicate: (value: T, index: number, items: T[]) => any): boolean;
    includes(predicate: (value: T, index: number, items: T[]) => Promise<any>): Promise<boolean>;
    /**
     * Creates an array of unique values that are included in both given array
     *
     * @param {Array} items
     *
     * @returns {Array}
     */
    intersect(items: T[]): SyncCollection<T>;
    /**
     * Returns `true` when the collection is empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isEmpty(): boolean;
    /**
     * Returns `true` when the collection is not empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isNotEmpty(): boolean;
    /**
     * Returns a string by concatenating all of the items
     * in an array with the given `separator`.
     *
     * @param {String} separator
     *
     * @returns {String}
     */
    join(separator: string): string;
    /**
     * Returns the last item in the collection that satisfies the
     * `predicate` testing function, `undefined` otherwise.
     *
     * @param {Function} callback
     *
     * @returns {*} the found value
     */
    last(predicate?: (value: T, index: number, items: T[]) => T): T;
    last(predicate?: (value: T, index: number, items: T[]) => Promise<T>): Promise<T>;
    /**
     * Asynchronous version of Array#map(), running all transformations
     * in sequence. It runs the given `callback` on each item of
     * the `array` and returns an array of transformed items.
     *
     * @param {Function} action
     *
     * @returns {Array}
     */
    map<R>(action: (value: T, index: number, items: T[]) => R): SyncCollection<R>;
    map<R>(action: (value: T, index: number, items: T[]) => Promise<R>): PendingAsyncCollection<R>;
    /**
     * Returns the max value in the collection.
     *
     * @returns {Number}
     */
    max(): number;
    /**
     * Returns median of the current collection
     *
     * @returns {Number}
     */
    median(): number;
    /**
     * Returns the min value in the collection.
     *
     * @returns {Number}
     */
    min(): number;
    /**
     * Retrieves all values for the given `keys`.
     *
     * @param {String|Array} keys
     *
     * @returns {Array}
     */
    pluck(keys: string | string[]): SyncCollection<T>;
    /**
   * Retrieves all values for a single `key`.
   *
   * @param {String} key
   *
   * @returns {Array}
   */
    pluckOne(key: string): SyncCollection<T>;
    /**
     * Retrieves all values as an array of objects where
     * each object contains the given `keys`.
     *
     * @param {Array} keys
     *
     * @returns {Array}
     */
    pluckMany(keys: string[]): SyncCollection<T>;
    /**
     * Removes and returns the last item from the collection.
     *
     * @returns {*}
     */
    pop(): T;
    /**
     * Add one or more items to the end of the collection.
     *
     * @param  {*} items
     *
     * @returns {SyncCollection}
     */
    push(...items: T[]): this;
    /**
     * Asynchronous version of Array#reduce(). It invokes the `reducer`
     * function sequentially on each `array` item. The reducer
     * transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} accumulator
     *
     * @returns {*} resulting accumulator value
     */
    reduce<R>(reducer: (carry: R, currentValue: T, currentIndex?: number, items?: T[]) => R, accumulator: R): R;
    reduce<R>(reducer: (carry: R, currentValue: T, currentIndex?: number, items?: T[]) => Promise<R>, accumulator: R): Promise<R>;
    /**
     * Asynchronous version of Array#reduceRight(). It invokes the `reducer`
     * function sequentially on each `array` item, from right-to-left. The
     * reducer transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} initial accumulator value
     *
     * @returns {*} resulting accumulator value
     */
    reduceRight<R>(reducer: (carry: R, currentValue: T, currentIndex: number, items: T[]) => Promise<R>, accumulator: R): Promise<R>;
    reduceRight<R>(reducer: (carry: R, currentValue: T, currentIndex: number, items: T[]) => R, accumulator: R): R;
    /**
     * Inverse of Array#filter(), **removing** all items satisfying the `callback`
     * testing function. Processes each item in sequence. The callback should
     * return `true` if an item should be removed from the resulting collection.
     *
     * @param {Function} predicate
     *
     * @returns {Array}
     */
    reject(predicate: (value: T, index: number, items: T[]) => Promise<unknown>): PendingAsyncCollection<T>;
    reject(predicate: (value: T, index: number, items: T[]) => unknown): SyncCollection<T>;
    /**
    * Returns a reversed collection. The first item becomes the last one,
    * the second item becomes the second to last, and so on.
    *
    * @returns {SyncCollection}
    */
    reverse(): SyncCollection<T>;
    /**
     * Removes and returns the first item from the collection.
     *
     * @returns {*}
     */
    shift(): T | undefined;
    /**
     * Returns the number of items in the collection.
     *
     * @returns {Number}
     */
    size(): number;
    /**
     * Returns a chunk of items beginning at the `start`
     * index without removing them from the collectin.
     * You can `limit` the size of the slice.
     *
     * @param {Number} start
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    slice(start: number, limit?: number): SyncCollection<T>;
    /**
     * Removes and returns a chunk of items beginning at the `start`
     * index. You can `limit` the size of the slice. You may also
     * replace the removed chunk with new items.
     *
     * @param {Number} start
     * @param {Number} limit
     * @param  {Array} inserts
     *
     * @returns {SyncCollection}
     */
    splice(start: number, limit?: number, ...inserts: T[]): SyncCollection<T>;
    /**
     * Asynchronous version of `Array#some()`, running the (async) testing function
     * in sequence. Returns `true` if at least one element in the collection
     * passes the check implemented by the `callback`, otherwise `false`.
     *
     * @param {Function} predicate
     *
     * @returns {Boolean}
     */
    some(predicate: (value: T, index: number, items: T[]) => Promise<unknown>): Promise<boolean>;
    some(predicate: (value: T, index: number, items: T[]) => unknown): boolean;
    /**
     * Returns a sorted list of all collection items, with an optional comparator
     *
     * @param {Function} comparator
     *
     * @returns {SyncCollection}
     */
    sort(comparator: (a: T, b: T) => number): SyncCollection<T>;
    /**
     * Returns the sum of all collection items.
     *
     * @returns {Number} resulting sum of collection items
     */
    sum(): number;
    /**
     * Take `limit` items from the beginning
     * or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    take(limit: number): SyncCollection<T>;
    /**
     * Take and remove `limit` items from the
     * beginning or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    takeAndRemove(limit: number): SyncCollection<T>;
    /**
     * Tap into the chain, run the given `callback` and retreive the original value.
     *
     * @returns {SyncCollection}
     */
    tap(_callback: (item: T) => void): this;
    /**
     * Returns JSON representation of collection
     *
     * @returns {String}
     */
    toJSON(): string;
    /**
     * Creates an array of unique values, in order, from all given arrays.
     *
     * @param {Array} items
     *
     * @returns {SyncCollection}
     */
    union(items: T[]): SyncCollection<T>;
    /**
     * Returns all the unique items in the collection.
     *
     * @param {String|Function}
     *
     * @returns {SyncCollection}
     */
    unique(key?: string | Function): SyncCollection<T>;
    /**
     * Returns all unique items in the collection identified by the given `selector`.
     *
     * @param {Function}
     *
     * @returns {SyncCollection}
     */
    uniqueBy(selector: (item: T) => unknown): SyncCollection<T>;
    uniqueBy(selector: (item: T) => unknown | Promise<unknown>): PendingAsyncCollection<T>;
    /**
     * Create a value receiving callback.
     *
     * @param {*} value
     *
     * @returns {Function}
     */
    private valueRetriever;
    /**
     * Add one or more items to the beginning of the collection.
     *
     * @returns {SyncCollection}
     */
    unshift(...items: T[]): this;
    /**
     * Enqueues an operation in the collection pipeline
     * for processing at a later time.
     *
     * @param {String} method
     * @param {Function} callback
     * @param {*} data
     *
     * @returns {SyncCollection}
     */
    private proxy;
}
