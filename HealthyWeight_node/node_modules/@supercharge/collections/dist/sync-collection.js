'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncCollection = void 0;
const goodies_1 = require("@supercharge/goodies");
const pending_async_collection_1 = require("./pending-async-collection");
class SyncCollection {
    /**
     *
     * @param items
     * @param callChain
     */
    constructor(items) {
        this.items = [].concat(items || []);
    }
    /**
     * Returns the array of items.
     *
     * @returns {Array}
     */
    all() {
        return this.items;
    }
    any(callback) {
        return this.some(callback);
    }
    /**
     * Returns the average of all collection items
     *
     * @returns {Number}
     */
    avg() {
        return this.sum() / this.size();
    }
    /**
     * Breaks the collection into multiple, smaller collections of the given `size`.
     *
     * @param {Number} size
     *
     * @returns {SyncCollection}
     */
    chunk(size) {
        const chunks = new SyncCollection([]);
        while (this.size()) {
            chunks.push(this.items.splice(0, size));
        }
        return chunks;
    }
    /**
     * Creates a shallow clone of the collection.
     *
     * @returns {SyncCollection}
     */
    clone() {
        return new SyncCollection(this.items);
    }
    /**
     * Collapse a collection of arrays into a single, flat collection.
     *
     * @returns {SyncCollection}
     */
    collapse() {
        return new SyncCollection([].concat(...this.items));
    }
    /**
     * Removes all falsy values from the given `array`. Falsy values
     * are `null`, `undefined`, `''`, `false`, `0`, `-0`, `0n`, `NaN`.
     *
     * @returns {SyncCollection}
     */
    compact() {
        return this.filter((item) => {
            return !!item;
        });
    }
    /**
     * Creates a new collection containing the concatenated items
     * of the original collection with the new `items`.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    concat(...items) {
        return new SyncCollection(this.clone().all().concat(...items));
    }
    count(predicate) {
        if (!predicate) {
            return this.size();
        }
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('count', predicate).all()
            : this.filter(predicate).size();
    }
    /**
     * Removes all values from the collection that are present in the given array.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    diff(items) {
        return new SyncCollection(this.items.filter((item) => {
            return !items.includes(item);
        }));
    }
    every(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('every', predicate)
            : this.items.every(predicate);
    }
    filter(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('filter', predicate)
            : new SyncCollection(this.items.filter(predicate));
    }
    filterIf(condition, predicate) {
        if (goodies_1.isAsyncFunction(predicate)) {
            return this.proxy('filterIf', predicate, condition);
        }
        return condition
            ? this.filter(predicate)
            : this;
    }
    find(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('find', predicate).all()
            : this.items.find(predicate);
    }
    first(predicate) {
        if (!predicate) {
            return this.items[0];
        }
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('first', predicate).all()
            : this.find(predicate);
    }
    /**
     * Flattens the collection one level deep.
     *
     * @returns {SyncCollection}
     */
    flatten() {
        return this.collapse();
    }
    flatMap(action) {
        return goodies_1.isAsyncFunction(action)
            ? this.proxy('flatMap', action)
            : this.map(action).collapse();
    }
    forEach(action) {
        return goodies_1.isAsyncFunction(action)
            ? this.proxy('forEach', action).all()
            : this.items.forEach(action);
    }
    /**
     * Group the collection items into arrays using the given `key`.
     *
     * @param {String} key
     *
     * @returns {Object}
     */
    groupBy(key) {
        if (key.includes('.')) {
            throw new Error('We do not support nested grouping yet. Please send a PR for that feature?');
        }
        return this.reduce((carry, item) => {
            const group = item[key] || '';
            if (carry[group] === undefined) {
                carry[group] = [];
            }
            carry[group].push(item);
            return carry;
        }, {});
    }
    has(predicate) {
        if (goodies_1.isAsyncFunction(predicate)) {
            return this.proxy('has', predicate);
        }
        return typeof predicate === 'function'
            ? !!this.find(predicate)
            : !!this.items.find((item) => {
                return item === predicate;
            });
    }
    /**
     * Returns `true` when the collection contains duplicate items, `false` otherwise.
     *
     * @returns {Boolean}
     */
    hasDuplicates() {
        return (new Set(this.items)).size !== this.size();
    }
    includes(predicate) {
        return this.has(predicate);
    }
    /**
     * Creates an array of unique values that are included in both given array
     *
     * @param {Array} items
     *
     * @returns {Array}
     */
    intersect(items) {
        return new SyncCollection([
            ...new Set(this.items.filter(value => items.includes(value)))
        ]);
    }
    /**
     * Returns `true` when the collection is empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isEmpty() {
        return this.size() === 0;
    }
    /**
     * Returns `true` when the collection is not empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isNotEmpty() {
        return !this.isEmpty();
    }
    /**
     * Returns a string by concatenating all of the items
     * in an array with the given `separator`.
     *
     * @param {String} separator
     *
     * @returns {String}
     */
    join(separator) {
        return this.items.join(separator);
    }
    last(predicate) {
        if (!predicate) {
            return this.items[this.size() - 1];
        }
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('last', predicate).all()
            : this.filter(predicate).last();
    }
    map(action) {
        return goodies_1.isAsyncFunction(action)
            ? this.proxy('map', action)
            : new SyncCollection(this.items.map(action));
    }
    /**
     * Returns the max value in the collection.
     *
     * @returns {Number}
     */
    max() {
        return Math.max(...this.items);
    }
    /**
     * Returns median of the current collection
     *
     * @returns {Number}
     */
    median() {
        const collection = this.sort((a, b) => a - b);
        const mid = Math.floor(collection.size() / 2);
        return collection.size() % 2 === 1
            ? collection.all()[mid]
            : (collection.all()[mid] + (collection.all()[mid - 1])) / 2; // eslint-disable-line
    }
    /**
     * Returns the min value in the collection.
     *
     * @returns {Number}
     */
    min() {
        return Math.min(...this.items);
    }
    /**
     * Retrieves all values for the given `keys`.
     *
     * @param {String|Array} keys
     *
     * @returns {Array}
     */
    pluck(keys) {
        keys = [].concat(keys);
        return keys.length === 1
            ? this.pluckOne(keys[0])
            : this.pluckMany(keys);
    }
    /**
   * Retrieves all values for a single `key`.
   *
   * @param {String} key
   *
   * @returns {Array}
   */
    pluckOne(key) {
        return this.map((item) => {
            return item[key];
        });
    }
    /**
     * Retrieves all values as an array of objects where
     * each object contains the given `keys`.
     *
     * @param {Array} keys
     *
     * @returns {Array}
     */
    pluckMany(keys) {
        return this.map((item) => {
            const result = {};
            keys.forEach(key => {
                result[key] = item[key];
            });
            return result;
        });
    }
    /**
     * Removes and returns the last item from the collection.
     *
     * @returns {*}
     */
    pop() {
        return goodies_1.tap(this.clone().last(), () => {
            this.items.pop();
        });
    }
    /**
     * Add one or more items to the end of the collection.
     *
     * @param  {*} items
     *
     * @returns {SyncCollection}
     */
    push(...items) {
        return goodies_1.tap(this, () => {
            this.items.push(...items);
        });
    }
    reduce(reducer, accumulator) {
        if (goodies_1.isAsyncFunction(reducer)) {
            return this.proxy('reduce', reducer, accumulator).all();
        }
        this.forEach((item, index) => {
            accumulator = reducer(accumulator, item, index, this.items);
        });
        return accumulator;
    }
    reduceRight(reducer, accumulator) {
        if (goodies_1.isAsyncFunction(reducer)) {
            return this.proxy('reduceRight', reducer, accumulator).all();
        }
        let index = this.items.length;
        while (index--) {
            accumulator = reducer(accumulator, this.items[index], index, this.items);
        }
        return accumulator;
    }
    reject(predicate) {
        if (goodies_1.isAsyncFunction(predicate)) {
            return this.proxy('reject', predicate);
        }
        return this.filter((item, index, items) => {
            return !predicate(item, index, items);
        });
    }
    /**
    * Returns a reversed collection. The first item becomes the last one,
    * the second item becomes the second to last, and so on.
    *
    * @returns {SyncCollection}
    */
    reverse() {
        return new SyncCollection(this.clone().all().reverse());
    }
    /**
     * Removes and returns the first item from the collection.
     *
     * @returns {*}
     */
    shift() {
        return goodies_1.tap(this.clone().first(), () => {
            this.items.shift();
        });
    }
    /**
     * Returns the number of items in the collection.
     *
     * @returns {Number}
     */
    size() {
        return this.items.length;
    }
    /**
     * Returns a chunk of items beginning at the `start`
     * index without removing them from the collectin.
     * You can `limit` the size of the slice.
     *
     * @param {Number} start
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    slice(start, limit) {
        return new SyncCollection(this.items
            .slice(start)
            .slice(0, limit));
    }
    /**
     * Removes and returns a chunk of items beginning at the `start`
     * index. You can `limit` the size of the slice. You may also
     * replace the removed chunk with new items.
     *
     * @param {Number} start
     * @param {Number} limit
     * @param  {Array} inserts
     *
     * @returns {SyncCollection}
     */
    splice(start, limit, ...inserts) {
        const flattend = Array.prototype.concat(...inserts);
        return new SyncCollection(this.items.splice(start, limit !== null && limit !== void 0 ? limit : this.size(), ...flattend));
    }
    some(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('some', predicate).all()
            : this.items.some(predicate);
    }
    /**
     * Returns a sorted list of all collection items, with an optional comparator
     *
     * @param {Function} comparator
     *
     * @returns {SyncCollection}
     */
    sort(comparator) {
        return new SyncCollection(this.clone().all().sort(comparator));
    }
    /**
     * Returns the sum of all collection items.
     *
     * @returns {Number} resulting sum of collection items
     */
    sum() {
        return new SyncCollection(this.items).reduce((carry, item) => {
            return carry + item;
        }, 0);
    }
    /**
     * Take `limit` items from the beginning
     * or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    take(limit) {
        const collection = this.clone();
        return limit < 0
            ? collection.slice(limit)
            : collection.slice(0, limit);
    }
    /**
     * Take and remove `limit` items from the
     * beginning or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    takeAndRemove(limit) {
        return limit < 0
            ? this.splice(limit)
            : this.splice(0, limit);
    }
    /**
     * Tap into the chain, run the given `callback` and retreive the original value.
     *
     * @returns {SyncCollection}
     */
    tap(_callback) {
        // return this.proxy('tap', callback)
        // TODO
        return this;
    }
    /**
     * Returns JSON representation of collection
     *
     * @returns {String}
     */
    toJSON() {
        return JSON.stringify(this.items);
    }
    /**
     * Creates an array of unique values, in order, from all given arrays.
     *
     * @param {Array} items
     *
     * @returns {SyncCollection}
     */
    union(items) {
        return this.concat(...items).unique();
    }
    /**
     * Returns all the unique items in the collection.
     *
     * @param {String|Function}
     *
     * @returns {SyncCollection}
     */
    unique(key) {
        if (key) {
            return this.uniqueBy(this.valueRetriever(key));
        }
        return new SyncCollection(Array.from(new Set(this.items)));
    }
    uniqueBy(selector) {
        if (goodies_1.isAsyncFunction(selector)) {
            return this.proxy('uniqueBy', selector);
        }
        const exists = new Set();
        return this.reject((item) => {
            const id = selector(item);
            if (exists.has(id)) {
                return true;
            }
            exists.add(id);
        });
    }
    /**
     * Create a value receiving callback.
     *
     * @param {*} value
     *
     * @returns {Function}
     */
    valueRetriever(value) {
        return typeof value === 'function'
            ? value
            : function (item) {
                return item[value];
            };
    }
    /**
     * Add one or more items to the beginning of the collection.
     *
     * @returns {SyncCollection}
     */
    unshift(...items) {
        return goodies_1.tap(this, () => {
            this.items.unshift(...items);
        });
    }
    /**
     * Enqueues an operation in the collection pipeline
     * for processing at a later time.
     *
     * @param {String} method
     * @param {Function} callback
     * @param {*} data
     *
     * @returns {SyncCollection}
     */
    proxy(method, callback, data) {
        return new pending_async_collection_1.PendingAsyncCollection(this.items).enqueue(method, callback, data);
    }
}
exports.SyncCollection = SyncCollection;
