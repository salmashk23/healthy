import { PendingAsyncCollection } from './pending-async-collection';
export declare class SyncCollection<T> {
    /**
     * Stores the list of items in the collection.
     */
    private readonly items;
    /**
     *
     * @param items
     * @param callChain
     */
    constructor(items: T[]);
    /**
     * Alias for the `.some` method. This function determines
     * whether any item in the `array` passes the truth test
     * implemented by the given `callback` function.
     *
     * @param {Function} callback
     *
     * @returns {Boolean}
     */
    any(callback: (value: T, index: number, items: T[]) => Promise<unknown>): Promise<boolean>;
    any(callback: (value: T, index: number, items: T[]) => unknown): boolean;
    /**
     * Returns the average of all collection items
     *
     * @returns {Number}
     */
    avg(): Promise<number>;
    /**
     * Breaks the collection into multiple, smaller collections of the given `size`.
     *
     * @param {Number} size
     *
     * @returns {SyncCollection}
     */
    chunk(size: number): SyncCollection<T[]>;
    /**
     * Creates a shallow clone of the collection.
     *
     * @returns {SyncCollection}
     */
    clone(): SyncCollection<T>;
    /**
     * Collapse a collection of arrays into a single, flat collection.
     *
     * @returns {SyncCollection}
     */
    collapse(): SyncCollection<T>;
    /**
     * Removes all falsy values from the given `array`. Falsy values
     * are `null`, `undefined`, `''`, `false`, `0`, `-0`, `0n`, `NaN`.
     *
     * @returns {SyncCollection}
     */
    compact(): SyncCollection<T>;
    /**
     * Creates a new collection containing the concatenated items
     * of the original collection with the new `items`.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    concat(...items: T[]): SyncCollection<T>;
    /**
     * Counts the items in the collection. By default, it behaves like an alias
     * for the `size()` method counting each individual item. The `callback`
     * function allows you to count a subset of items in the collection.
     *
     * @param {Function} callback
     *
     * @returns {Number}
     */
    count(callback?: Function): Promise<number>;
    /**
     * Removes all values from the collection that are present in the given array.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    diff(items: T[]): SyncCollection<T>;
    /**
     * Asynchronous version of `Array#every()`, running the (async) testing
     * function in sequence. Returns `true` if all items in the collection
     * pass the check implemented by the `callback`, otherwise `false`.
     *
     * @param {Function} callback
     *
     * @returns {Boolean} Returns `true` if all items pass the predicate check, `false` otherwise.
     */
    every(callback: (value: T, index: number, items: T[]) => unknown | Promise<unknown>): Promise<boolean>;
    /**
     * Asynchronous version of Array#filter(), running the (async) testing
     * function in sequence. The `callback` should return `true`
     * if an item should be included in the resulting collection.
     *
     * @param {Function} predicate
     *
     * @returns {Array}
     */
    filter(predicate: (value: T, index: number, items: T[]) => Promise<unknown>): PendingAsyncCollection<T>;
    filter(predicate: (value: T, index: number, items: T[]) => unknown): SyncCollection<T>;
    /**
     * A variant of the `filter` method running the (async) testing
     * function only if the given `condition` is `true`.
     *
     * @param {Boolean} condition
     * @param {Function} callback
     *
     * @returns {Array}
     */
    filterIf(condition: boolean, predicate: (value: T, index: number, items: T[]) => Promise<unknown>): PendingAsyncCollection<T>;
    filterIf(condition: boolean, predicate: (value: T, index: number, items: T[]) => unknown): this;
    /**
     * Asynchronous version of Array#find(), running the (async) testing
     * function in sequence. Returns the first item in the collection
     * satisfying the given `callback`, `undefined` otherwise.
     *
     * @param {Function} predicate
     *
     * @returns {*} the found value
     */
    find(predicate: (value: T, index: number, items: T[]) => Promise<T>): Promise<T>;
    find(predicate: (value: T, index: number, items: T[]) => T): T;
    /**
     * Returns the first item in the collection. This method behaves like
     * Array#find if you provide a `predicate` function.
     *
     * @param {Function} predicate
     *
     * @returns {*} the found value
     */
    first(predicate?: (value: T, index: number, items: T[]) => T): Promise<T>;
    first(predicate?: (value: T, index: number, items: T[]) => T): T;
    /**
     * Flattens the collection one level deep.
     *
     * @returns {SyncCollection}
     */
    flatten(): SyncCollection<T>;
    /**
     * Asynchronous version of Array#flatMap(). It invokes the `callback`
     * on each collection item. The callback can modify and return the
     * item resulting in a new collection of modified items.
     * Ultimately, flatMap flattens the mapped results.
     *
     * @param {Function} callback
     *
     * @returns {SyncCollection}
     */
    flatMap<R>(callback: (value: T, index: number, items: T[]) => R[] | Promise<R[]>): SyncCollection<any>;
    /**
     * Asynchrounous version of Array#forEach(), running the given
     * `callback` function on each `array` item in sequence.
     *
     * @param {Function} callback
     */
    forEach(callback: (value: T, index: number, items: T[]) => void | Promise<void>): Promise<void>;
    /**
     * Group the collection items into arrays using the given `key`.
     *
     * @param {String} key
     *
     * @returns {Object}
     */
    groupBy(key: string): Promise<any>;
    /**
     * Determines whether the the collection contains the item
     * represented by `callback` or if the collection
     * satisfies the given `callback` testing function.
     *
     * @param {Function} predicate
     *
     * @returns {Boolean}
     */
    has(predicate: (value: T, index: number, items: T[]) => Promise<boolean>): Promise<boolean>;
    has(predicate: (value: T, index: number, items: T[]) => boolean): boolean;
    /**
     * Returns `true` when the collection contains duplicate items, `false` otherwise.
     *
     * @returns {Boolean}
     */
    hasDuplicates(): Promise<boolean>;
    /**
     * Creates an array of unique values that are included in both given array
     *
     * @param {Array} items
     *
     * @returns {Array}
     */
    intersect(items: T[]): this;
    /**
     * Returns `true` when the collection is empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isEmpty(): Promise<boolean>;
    /**
     * Returns `true` when the collection is not empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isNotEmpty(): Promise<boolean>;
    /**
     * Returns a string by concatenating all of the items
     * in an array with the given `separator`.
     *
     * @param {String} separator
     *
     * @returns {String}
     */
    join(separator: string): Promise<string>;
    /**
     * Returns the last item in the collection that satisfies the
     * `predicate` testing function, `undefined` otherwise.
     *
     * @param {Function} callback
     *
     * @returns {*} the found value
     */
    last<S extends T>(predicate: (value: T, index: number, items: T[]) => value is S): Promise<S>;
    /**
     * Asynchronous version of Array#map(), running all transformations
     * in sequence. It runs the given `callback` on each item of
     * the `array` and returns an array of transformed items.
     *
     * @param {Function} callback
     *
     * @returns {Array}
     */
    map<R>(callback: (value: T, index: number, items: T[]) => R[]): SyncCollection<any>;
    /**
     * Returns the max value in the collection.
     *
     * @returns {Number}
     */
    max(): Promise<number>;
    /**
     * Returns median of the current collection
     *
     * @returns {Number}
     */
    median(): Promise<number>;
    /**
     * Returns the min value in the collection.
     *
     * @returns {Number}
     */
    min(): Promise<number>;
    /**
     * Retrieves all values for the given `keys`.
     *
     * @param {String|Array} keys
     *
     * @returns {Array}
     */
    pluck(keys: string | string[]): this;
    /**
     * Removes and returns the last item from the collection.
     *
     * @returns {*}
     */
    pop(): Promise<any>;
    /**
     * Add one or more items to the end of the collection.
     *
     * @param  {*} items
     *
     * @returns {SyncCollection}
     */
    push(...items: T[]): this;
    /**
     * Asynchronous version of Array#reduce(). It invokes the `reducer`
     * function sequentially on each `array` item. The reducer
     * transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} initial accumulator value
     *
     * @returns {*} resulting accumulator value
     */
    reduce<R>(reducer: (carry: R, currentValue: T, currentIndex: number, items: T[]) => R | Promise<R>, initial: R): Promise<R>;
    /**
     * Asynchronous version of Array#reduceRight(). It invokes the `reducer`
     * function sequentially on each `array` item, from right-to-left. The
     * reducer transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} initial accumulator value
     *
     * @returns {*} resulting accumulator value
     */
    reduceRight<R>(reducer: (carry: R, currentValue: T, currentIndex: number, items: T[]) => R | Promise<R>, initial: R): Promise<R>;
    /**
     * Inverse of Array#filter(), **removing** all items satisfying the `callback`
     * testing function. Processes each item in sequence. The callback should
     * return `true` if an item should be removed from the resulting collection.
     *
     * @param {Function} predicate
     *
     * @returns {Array}
     */
    reject(predicate: (value: T, index: number, items: T[]) => unknown | Promise<unknown>): this;
    /**
    * Returns a reversed collection. The first item becomes the last one,
    * the second item becomes the second to last, and so on.
    *
    * @returns {SyncCollection}
    */
    reverse(): SyncCollection<T>;
    /**
     * Removes and returns the first item from the collection.
     *
     * @returns {*}
     */
    shift(): Promise<T>;
    /**
     * Returns the number of items in the collection.
     *
     * @returns {Number}
     */
    size(): number;
    /**
     * Returns a chunk of items beginning at the `start`
     * index without removing them from the collectin.
     * You can `limit` the size of the slice.
     *
     * @param {Number} start
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    slice(start: number, limit?: number): this;
    /**
     * Removes and returns a chunk of items beginning at the `start`
     * index. You can `limit` the size of the slice. You may also
     * replace the removed chunk with new items.
     *
     * @param {Number} start
     * @param {Number} limit
     * @param  {Array} inserts
     *
     * @returns {SyncCollection}
     */
    splice(start: number, limit: number, ...inserts: T[]): SyncCollection<T>;
    /**
     * Asynchronous version of `Array#some()`, running the (async) testing function
     * in sequence. Returns `true` if at least one element in the collection
     * passes the check implemented by the `callback`, otherwise `false`.
     *
     * @param {Function} predicate
     *
     * @returns {Boolean}
     */
    some(predicate: (value: T, index: number, items: T[]) => Promise<unknown>): Promise<boolean>;
    some(predicate: (value: T, index: number, items: T[]) => unknown): boolean;
    /**
     * Returns a sorted list of all collection items, with an optional comparator
     *
     * @param {Function} comparator
     *
     * @returns {SyncCollection}
     */
    sort(comparator: (a: T, b: T) => number): SyncCollection<T>;
    /**
     * Returns the sum of all collection items.
     *
     * @returns {Number} resulting sum of collection items
     */
    sum(): Promise<number>;
    /**
     * Take `limit` items from the beginning
     * or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    take(limit: number): SyncCollection<T>;
    /**
     * Take and remove `limit` items from the
     * beginning or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    takeAndRemove(limit: number): SyncCollection<T>;
    /**
     * Tap into the chain, run the given `callback` and retreive the original value.
     *
     * @returns {SyncCollection}
     */
    tap(callback: (item: T) => void): this;
    /**
     * Returns JSON representation of collection
     *
     * @returns {String}
     */
    toJSON(): Promise<string>;
    /**
     * Creates an array of unique values, in order, from all given arrays.
     *
     * @param {Array} items
     *
     * @returns {SyncCollection}
     */
    union(items: T[]): SyncCollection<T>;
    /**
     * Returns all the unique items in the collection.
     *
     * @param {String|Function}
     *
     * @returns {SyncCollection}
     */
    unique(key?: string | Function): this;
    /**
     * Returns all unique items in the collection identified by the given `selector`.
     *
     * @param {Function}
     *
     * @returns {SyncCollection}
     */
    uniqueBy(selector: (item: T) => unknown | Promise<unknown>): this;
    /**
     * Add one or more items to the beginning of the collection.
     *
     * @returns {*}
     */
    unshift(...items: T[]): this;
    /**
     * Enqueues an operation in the collection pipeline
     * for processing at a later time.
     *
     * @param {String} method
     * @param {Function} callback
     * @param {*} data
     *
     * @returns {SyncCollection}
     */
    private proxy;
    /**
     * Creates a “thenable” allowing you to await collection
     * pipelines instead of appending a `.all()` call.
     *
     * @param {Function} onFullfilled
     *
     * @returns {*}
     */
    then(onFullfilled: (value: any) => any, onRejected: (value: any) => any): Promise<void>;
    /**
     * Processes the collection pipeline and returns
     * all items in the collection.
     *
     * @returns {*}
     */
    all(): Promise<any>;
}
