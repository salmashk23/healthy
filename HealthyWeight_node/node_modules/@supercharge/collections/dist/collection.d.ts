export declare class Collection {
    private items;
    constructor(items?: any[]);
    /**
     * Processes the collection pipeline and returns
     * all items in the collection.
     *
     * @returns {Array}
     */
    all(): any[];
    /**
     * Returns the average of all collection items.
     *
     * @returns {Number}
     * */
    avg(): Promise<number>;
    /**
     * Breaks the collection into multiple, smaller collections
     * of the given `size`.
     *
     * @param {Number} size
     *
     * @returns {Array}
     */
    chunk(size: number): any[];
    /**
     * Collapse a collection of arrays into a single, flat collection.
     *
     * @returns {Array}
     */
    collapse(): any[];
    /**
     * Removes all falsey values from the given `array`.
     * Falsey values are `null`, `undefined`, `''`,
     * `false`, `0`, `NaN`.
     *
     * @returns {Array}
     */
    compact(): Promise<any[]>;
    /**
     * Creates a new collection containing the
     * concatenated items of the original
     * collection with the new `items`.
     *
     * @param {Array} items
     *
     * @returns {Array}
     */
    concat(items: any[]): any[];
    /**
     * Counts the items in the collection. By default, it behaves like an alias
     * for the `size()` method counting each individual item. The `callback`
     * function allows you to count a subset of items in the collection.
     *
     * @param {Function} callback
     *
     * @returns {Number}
     */
    count(callback?: Function): Promise<number>;
    /**
     * Removes all values from the collection that are present in the given array.
     *
     * @param {*} items
     *
     * @returns {CollectionProxy}
     */
    diff(items: any[]): any[];
    /**
     * Asynchronous version of `Array#every()`, running the (async) testing
     * function in sequence. Returns `true` if all items in the collection
     * pass the check implemented by the `callback`, otherwise `false`.
     *
     * @param {Function} callback
     *
     * @returns {Boolean} Returns `true` if all items pass the predicate check, `false` otherwise.
     */
    every(callback: Function): Promise<boolean>;
    /**
     * Asynchronous version of Array#filter(), running the (async) testing
     * function in sequence. The `callback` should return `true`
     * if an item should be included in the resulting collection.
     *
     * @param {Function} callback
     *
     * @returns {Array}
     */
    filter(callback: Function): Promise<any[]>;
    /**
     * A variant of the `filter` method running the (async) testing
     * function only if the given `condition` is `true`.
     *
     * @param {Function} callback
     * @param {Boolean} condition
     *
     * @returns {Array}
     */
    filterIf(callback: Function, condition: boolean): Promise<any[]>;
    /**
     * Asynchronous version of Array#find(), running the (async) testing
     * function in sequence. Returns the first item in the collection
     * satisfying the given `callback`, `undefined` otherwise.
     *
     * @param {Function} callback
     *
     * @returns {*} the found value
     */
    find(callback: Function): Promise<any | undefined>;
    /**
     * Alias for "find".
     *
     * @param {Function} callback
     *
     * @returns {*} the found value
     */
    first(callback?: Function): Promise<any>;
    /**
     * Asynchronous version of Array#flatMap(). It invokes the `callback`
     * on each collection item. The callback can modify and return the
     * item resulting in a new collection of modified items.
     * Ultimately, flatMap flattens the mapped results.
     *
     * @param {Function} callback
     *
     * @returns {Array}
     */
    flatMap(callback: Function): Promise<any[]>;
    /**
     * Asynchrounous version of Array#forEach(), running the given
     * `callback` function on each `array` item in sequence.
     *
     * @param {Function} callback
     */
    forEach(callback: Function): Promise<void>;
    /**
     * Group the collection items into arrays using the given `key`.
     *
     * @param {String} key
     *
     * @returns {Object}
     */
    groupBy(key: string): Promise<any>;
    /**
     * Determines whether the the collection contains the item
     * represented by `callback` or if the collection
     * satisfies the given `callback` testing function. Alias of `includes`.
     *
     * @param {Function} callback
     *
     * @returns {Boolean}
     */
    has(callback: Function): Promise<boolean>;
    /**
     * Returns `true` when the collection contains duplicate items, `false` otherwise.
     *
     * @returns {Boolean}
     */
    hasDuplicates(): Promise<boolean>;
    /**
     * Determines whether the the collection contains the item
     * represented by `callback` or if the collection
     * satisfies the given `callback` testing function. Alias of `has`.
     *
     * @param {Function} callback
     *
     * @returns {Boolean}
     */
    includes(callback: Function): Promise<boolean>;
    /**
     * Creates an array of unique values that are included in both given array.
     *
     * @param {Array} items
     *
     * @returns {Array}
     */
    intersect(items: any[]): any[];
    /**
     * Returns `true` when the collection is empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isEmpty(): boolean;
    /**
     * Returns `true` when the collection is not empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    isNotEmpty(): boolean;
    /**
     * Returns a new string by concatenating all of the elements in an array.
     *
     * @returns {String}
     */
    join(separator: string): string;
    /**
     * Returns the last item in the collection that satisfies
     * the `callback` testing function, `undefined` otherwise.
     *
     * @param {Function} callback
     *
     * @returns {*} the found value
     */
    last(callback: Function): Promise<any>;
    /**
     * Asynchronous version of Array#map(), running all transformations
     * in sequence. It runs the given `callback` on each item of
     * the `array` and returns an array of transformed items.
     *
     * @param {Function} callback
     *
     * @returns {Array}
     */
    map(callback: Function): Promise<any[]>;
    /**
     * Returns the max value in the collection.
     *
     * @returns {Number}
     */
    max(): number;
    /**
     * Returns median of the current collection.
     *
     * @param {}
     *
     * @returns {Number}
     */
    median(): number;
    /**
     * Returns the min value in the collection.
     *
     * @returns {Number}
     */
    min(): number;
    /**
     * Retrieves all values for the given `keys`.
     *
     * @param {String|Array} keys
     *
     * @returns {Array}
     */
    pluck(key: string | string[]): Promise<any[]>;
    /**
     * Retrieves all values for a single `key`.
     *
     * @param {String} key
     *
     * @returns {Array}
     */
    pluckOne(key: string): Promise<any[]>;
    /**
     * Retrieves all values as an array of objects where
     * each object contains the given `keys`.
     *
     * @param {Array} keys
     *
     * @returns {Array}
     */
    pluckMany(keys: string[]): Promise<any[]>;
    /**
     * Removes and returns the last item from the collection.
     *
     * @param {}
     *
     * @returns {Number}
     */
    pop(): any;
    /**
     * Add one or more items to the end of the colleciton.
     *
     * @param  {*} items
     *
     * @returns {Collection}
     */
    push(items: any[]): this;
    /**
     * Asynchronous version of Array#reduce(). It invokes the `reducer`
     * function sequentially on each `array` item. The reducer
     * transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} initial accumulator value
     *
     * @returns {*} resulting accumulator value
     */
    reduce(reducer: Function, accumulator: any): Promise<any>;
    /**
     * Asynchronous version of Array#reduceRight(). It invokes the `reducer`
     * function sequentially on each `array` item, from right-to-left. The
     * reducer transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} initial accumulator value
     *
     * @returns {*} resulting accumulator value
     */
    reduceRight(reducer: Function, accumulator: any): Promise<any>;
    /**
     * Inverse of Array#filter(), **removing** all items satisfying the `callback`
     * testing function. Processes each item in sequence. The callback should
     * return `true` if an item should be removed from the resulting collection.
     *
     * @param {Function} callback
     *
     * @returns {Array}
     */
    reject(callback: Function): Promise<any[]>;
    /**
    * Returns reversed version of original collection.
    *
    * @returns {Array}
    */
    reverse(): any[];
    /**
     * Removes and returns the first item from the collection.
     *
     * @returns {*}
     */
    shift(): any;
    /**
     * Returns the number of items in the collection.
     *
     * @returns {Number}
     */
    size(): number;
    /**
     * Returns a chunk of items beginning at the `start`
     * index without removing them from the collection.
     * You can `limit` the size of the slice.
     *
     * @param {Number} start
     * @param {Number} limit
     *
     * @returns {Array}
     */
    slice(options: any): any[];
    /**
    * Removes and returns a chunk of items beginning at the `start`
    * index from the collection. You can `limit` the size of the
    * slice and replace the removed items with `inserts`.
    *
    * @param {Number} start
    * @param {Number} limit
    * @param {*} inserts
    *
    * @returns {Array}
    */
    splice(options: any): any[];
    /**
     * Asynchronous version of `Array#some()`, running the (async) testing function
     * in sequence. Returns `true` if at least one element in the collection
     * passes the check implemented by the `callback`, otherwise `false`.
     *
     * @param {Function} callback
     *
     * @returns {Boolean}
     */
    some(callback: Function): Promise<boolean>;
    /**
     * Returns a sorted list of all collection items, with an optional comparator.
     *
     * @param {Function} comparator
     *
     * @returns {Collection}
     */
    sort(comparator: (a: any, b: any) => number): any[];
    /**
     * Returns the sum of all collection items.
     *
     * @returns {Number} resulting sum of collection items
     */
    sum(): Promise<number>;
    /**
     * Take and remove `limit` items from the
     * beginning or end of the collection.
     *
     * @param {Integer} limit
     *
     * @returns {Array}
     */
    takeAndRemove(limit: number): any[];
    /**
     * Tap into the chain, run the given `callback` and retreive the original value.
     *
     * @returns {Collection}
     */
    tap(callback: Function): Promise<this>;
    /**
     * Returns JSON representation of collection.
     *
     * @returns {String}
     */
    toJSON(): string;
    /**
     * Returns all the unique items in the collection.
     *
     * @param {String|Function}
     *
     * @returns {Array}
     */
    unique(key?: string | Function): Promise<any[]>;
    /**
     * Returns all unique items in the collection identified by the given `selector`.
     *
     * @param {Function}
     *
     * @returns {Array}
     */
    uniqueBy(selector: (item: any) => any): Promise<any[]>;
    /**
     * Create a value receiving callback.
     *
     * @param {*} value
     *
     * @returns {Function}
     */
    valueRetriever(value: Function | any): (item: any) => any;
    /**
     * Add one or more items to the beginning of the collection.
     *
     * @returns {Collection}
     */
    unshift(items: any[]): this;
}
