'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncCollection = void 0;
const collection_1 = require("./collection");
const goodies_1 = require("@supercharge/goodies");
const pending_async_collection_1 = require("./pending-async-collection");
class SyncCollection {
    /**
     *
     * @param items
     * @param callChain
     */
    constructor(items) {
        this.items = [].concat(items || []);
    }
    any(callback) {
        return this.some(callback);
    }
    /**
     * Returns the average of all collection items
     *
     * @returns {Number}
     */
    async avg() {
        return this.proxy('avg').all();
    }
    /**
     * Breaks the collection into multiple, smaller collections of the given `size`.
     *
     * @param {Number} size
     *
     * @returns {SyncCollection}
     */
    chunk(size) {
        const chunks = new SyncCollection([]);
        while (this.size()) {
            chunks.push(this.items.splice(0, size));
        }
        return chunks;
    }
    /**
     * Creates a shallow clone of the collection.
     *
     * @returns {SyncCollection}
     */
    clone() {
        return new SyncCollection(this.items);
    }
    /**
     * Collapse a collection of arrays into a single, flat collection.
     *
     * @returns {SyncCollection}
     */
    collapse() {
        return new SyncCollection([...this.items]);
    }
    /**
     * Removes all falsy values from the given `array`. Falsy values
     * are `null`, `undefined`, `''`, `false`, `0`, `-0`, `0n`, `NaN`.
     *
     * @returns {SyncCollection}
     */
    compact() {
        return this.filter((item) => {
            return !!item;
        });
    }
    /**
     * Creates a new collection containing the concatenated items
     * of the original collection with the new `items`.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    concat(...items) {
        return new SyncCollection(this.items.concat([...items]));
    }
    /**
     * Counts the items in the collection. By default, it behaves like an alias
     * for the `size()` method counting each individual item. The `callback`
     * function allows you to count a subset of items in the collection.
     *
     * @param {Function} callback
     *
     * @returns {Number}
     */
    count(callback) {
        return this.proxy('count', callback).all();
    }
    /**
     * Removes all values from the collection that are present in the given array.
     *
     * @param {*} items
     *
     * @returns {SyncCollection}
     */
    diff(items) {
        return new SyncCollection(this.items.filter((item) => {
            return !items.includes(item);
        }));
    }
    /**
     * Asynchronous version of `Array#every()`, running the (async) testing
     * function in sequence. Returns `true` if all items in the collection
     * pass the check implemented by the `callback`, otherwise `false`.
     *
     * @param {Function} callback
     *
     * @returns {Boolean} Returns `true` if all items pass the predicate check, `false` otherwise.
     */
    async every(callback) {
        return this.proxy('every', callback);
    }
    filter(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('filter', predicate)
            : new SyncCollection(this.items.filter(predicate));
    }
    filterIf(condition, predicate) {
        if (goodies_1.isAsyncFunction(predicate)) {
            return this.proxy('filter', predicate, condition);
        }
        return condition
            ? this.filter(predicate)
            : this;
    }
    find(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('find', predicate).all()
            : this.items.find(predicate);
    }
    first(predicate) {
        if (!predicate) {
            return this.items[0];
        }
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('first', predicate).all()
            : this.find(predicate);
    }
    /**
     * Flattens the collection one level deep.
     *
     * @returns {SyncCollection}
     */
    flatten() {
        return this.collapse();
    }
    /**
     * Asynchronous version of Array#flatMap(). It invokes the `callback`
     * on each collection item. The callback can modify and return the
     * item resulting in a new collection of modified items.
     * Ultimately, flatMap flattens the mapped results.
     *
     * @param {Function} callback
     *
     * @returns {SyncCollection}
     */
    flatMap(callback) {
        return this.proxy('flatMap', callback);
    }
    /**
     * Asynchrounous version of Array#forEach(), running the given
     * `callback` function on each `array` item in sequence.
     *
     * @param {Function} callback
     */
    async forEach(callback) {
        return this.proxy('forEach', callback).all();
    }
    /**
     * Group the collection items into arrays using the given `key`.
     *
     * @param {String} key
     *
     * @returns {Object}
     */
    async groupBy(key) {
        return this.proxy('groupBy', undefined, key).all();
    }
    has(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('has', predicate)
            : !!this.find(predicate);
    }
    /**
     * Returns `true` when the collection contains duplicate items, `false` otherwise.
     *
     * @returns {Boolean}
     */
    async hasDuplicates() {
        return this.proxy('hasDuplicates');
    }
    /**
     * Creates an array of unique values that are included in both given array
     *
     * @param {Array} items
     *
     * @returns {Array}
     */
    intersect(items) {
        return this.proxy('intersect', undefined, items);
    }
    /**
     * Returns `true` when the collection is empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    async isEmpty() {
        return this.proxy('isEmpty');
    }
    /**
     * Returns `true` when the collection is not empty, `false` otherwise.
     *
     * @returns {Boolean}
     */
    async isNotEmpty() {
        return this.proxy('isNotEmpty');
    }
    /**
     * Returns a string by concatenating all of the items
     * in an array with the given `separator`.
     *
     * @param {String} separator
     *
     * @returns {String}
     */
    async join(separator) {
        return this.proxy('join', undefined, separator);
    }
    /**
     * Returns the last item in the collection that satisfies the
     * `predicate` testing function, `undefined` otherwise.
     *
     * @param {Function} callback
     *
     * @returns {*} the found value
     */
    async last(predicate) {
        return this.proxy('last', predicate).all();
    }
    /**
     * Asynchronous version of Array#map(), running all transformations
     * in sequence. It runs the given `callback` on each item of
     * the `array` and returns an array of transformed items.
     *
     * @param {Function} callback
     *
     * @returns {Array}
     */
    map(callback) {
        return this.proxy('map', callback);
    }
    /**
     * Returns the max value in the collection.
     *
     * @returns {Number}
     */
    async max() {
        return this.proxy('max');
    }
    /**
     * Returns median of the current collection
     *
     * @returns {Number}
     */
    async median() {
        return this.proxy('median');
    }
    /**
     * Returns the min value in the collection.
     *
     * @returns {Number}
     */
    async min() {
        return this.proxy('min');
    }
    /**
     * Retrieves all values for the given `keys`.
     *
     * @param {String|Array} keys
     *
     * @returns {Array}
     */
    pluck(keys) {
        return this.proxy('pluck', undefined, keys).collapse();
    }
    /**
     * Removes and returns the last item from the collection.
     *
     * @returns {*}
     */
    async pop() {
        const collection = this.clone();
        this.splice(-1, 1);
        return collection.proxy('pop');
    }
    /**
     * Add one or more items to the end of the collection.
     *
     * @param  {*} items
     *
     * @returns {SyncCollection}
     */
    push(...items) {
        return goodies_1.tap(this, () => {
            this.items.push(...items);
        });
    }
    /**
     * Asynchronous version of Array#reduce(). It invokes the `reducer`
     * function sequentially on each `array` item. The reducer
     * transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} initial accumulator value
     *
     * @returns {*} resulting accumulator value
     */
    async reduce(reducer, initial) {
        return this.proxy('reduce', reducer, initial).all();
    }
    /**
     * Asynchronous version of Array#reduceRight(). It invokes the `reducer`
     * function sequentially on each `array` item, from right-to-left. The
     * reducer transforms an accumulator value based on each item.
     *
     * @param {Function} reducer
     * @param {*} initial accumulator value
     *
     * @returns {*} resulting accumulator value
     */
    async reduceRight(reducer, initial) {
        return this.proxy('reduceRight', reducer, initial).all();
    }
    /**
     * Inverse of Array#filter(), **removing** all items satisfying the `callback`
     * testing function. Processes each item in sequence. The callback should
     * return `true` if an item should be removed from the resulting collection.
     *
     * @param {Function} predicate
     *
     * @returns {Array}
     */
    reject(predicate) {
        return this.proxy('reject', predicate);
    }
    /**
    * Returns a reversed collection. The first item becomes the last one,
    * the second item becomes the second to last, and so on.
    *
    * @returns {SyncCollection}
    */
    reverse() {
        return this.clone().proxy('reverse');
    }
    /**
     * Removes and returns the first item from the collection.
     *
     * @returns {*}
     */
    async shift() {
        const collection = this.clone();
        this.splice(0, 1);
        return collection.proxy('shift').all();
    }
    /**
     * Returns the number of items in the collection.
     *
     * @returns {Number}
     */
    size() {
        return this.items.length;
    }
    /**
     * Returns a chunk of items beginning at the `start`
     * index without removing them from the collectin.
     * You can `limit` the size of the slice.
     *
     * @param {Number} start
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    slice(start, limit) {
        return this.proxy('slice', undefined, { start, limit });
    }
    /**
     * Removes and returns a chunk of items beginning at the `start`
     * index. You can `limit` the size of the slice. You may also
     * replace the removed chunk with new items.
     *
     * @param {Number} start
     * @param {Number} limit
     * @param  {Array} inserts
     *
     * @returns {SyncCollection}
     */
    splice(start, limit, ...inserts) {
        const collection = this.clone().slice(start, limit);
        this.proxy('splice', undefined, { start, limit, inserts });
        return collection;
    }
    some(predicate) {
        return goodies_1.isAsyncFunction(predicate)
            ? this.proxy('some', predicate).all()
            : this.items.some(predicate);
    }
    /**
     * Returns a sorted list of all collection items, with an optional comparator
     *
     * @param {Function} comparator
     *
     * @returns {SyncCollection}
     */
    sort(comparator) {
        return this.clone().proxy('sort', comparator);
    }
    /**
     * Returns the sum of all collection items.
     *
     * @returns {Number} resulting sum of collection items
     */
    async sum() {
        return this.proxy('sum').all();
    }
    /**
     * Take `limit` items from the beginning
     * or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    take(limit) {
        const collection = this.clone();
        return limit < 0
            ? collection.slice(limit)
            : collection.slice(0, limit);
    }
    /**
     * Take and remove `limit` items from the
     * beginning or end of the collection.
     *
     * @param {Number} limit
     *
     * @returns {SyncCollection}
     */
    takeAndRemove(limit) {
        const collection = this.take(limit);
        this.proxy('takeAndRemove', undefined, limit);
        return collection;
    }
    /**
     * Tap into the chain, run the given `callback` and retreive the original value.
     *
     * @returns {SyncCollection}
     */
    tap(callback) {
        return this.proxy('tap', callback);
    }
    /**
     * Returns JSON representation of collection
     *
     * @returns {String}
     */
    async toJSON() {
        return this.proxy('toJSON').all();
    }
    /**
     * Creates an array of unique values, in order, from all given arrays.
     *
     * @param {Array} items
     *
     * @returns {SyncCollection}
     */
    union(items) {
        return this.concat(...items).unique();
    }
    /**
     * Returns all the unique items in the collection.
     *
     * @param {String|Function}
     *
     * @returns {SyncCollection}
     */
    unique(key) {
        return this.proxy('unique', undefined, key);
    }
    /**
     * Returns all unique items in the collection identified by the given `selector`.
     *
     * @param {Function}
     *
     * @returns {SyncCollection}
     */
    uniqueBy(selector) {
        return this.proxy('uniqueBy', selector);
    }
    /**
     * Add one or more items to the beginning of the collection.
     *
     * @returns {*}
     */
    unshift(...items) {
        return this.proxy('unshift', undefined, items);
    }
    /**
     * Enqueues an operation in the collection pipeline
     * for processing at a later time.
     *
     * @param {String} method
     * @param {Function} callback
     * @param {*} data
     *
     * @returns {SyncCollection}
     */
    proxy(method, callback, data) {
        return new pending_async_collection_1.PendingAsyncCollection(this.items).enqueue(method, callback, data);
    }
    /**
     * Creates a “thenable” allowing you to await collection
     * pipelines instead of appending a `.all()` call.
     *
     * @param {Function} onFullfilled
     *
     * @returns {*}
     */
    async then(onFullfilled, onRejected) {
        try {
            onFullfilled(await this.all());
        }
        catch (error) {
            onRejected(error);
        }
    }
    /**
     * Processes the collection pipeline and returns
     * all items in the collection.
     *
     * @returns {*}
     */
    async all() {
        let collection = new collection_1.Collection(this.items);
        while (this.callChain.isNotEmpty()) {
            try {
                const { method, callback, data } = this.callChain.dequeue();
                collection = await (callback
                    ? collection[method](callback, data)
                    : collection[method](data));
                if (collection instanceof Array) {
                    collection = new collection_1.Collection(collection);
                }
            }
            catch (error) {
                this.callChain.clear();
                throw error;
            }
        }
        if (collection instanceof collection_1.Collection) {
            return collection.all();
        }
        return collection;
    }
}
exports.SyncCollection = SyncCollection;
